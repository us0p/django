from django.http import Http404, HttpResponse, HttpRequest, HttpResponseRedirect
from django.urls import reverse
from django.utils import timezone
from django.template import loader
from django.shortcuts import get_object_or_404, render
from django.db.models import F
from django.views import generic

from .models import Question, Choice

# This view is imported in this app urls.py file and mapped to a path.
# This app urls.py file is further included in the project urls.py to make
# its routes globally available to the application.

# Note that in the default implementation of a view the templates have been
# provided with a context that contains the question and 
# latest_question_list context variables.
# For DetailView the question variable is provided automatically – since 
# we’re using a Django model (Question). However, for ListView, the 
# automatically generated context variable is question_list. To override 
# this we provide the context_object_name attribute, specifying that we 
# want to use latest_question_list instead.

# Each generic view needs to know what model it will be acting upon. This 
# is provided using either the model attribute or by defining the 
# get_queryset() method.
class IndexView(generic.ListView):
    template_name = "polls/index.html"
    context_object_name = "latest_question_list"

    def get_queryset(self):
        return Question.objects.filter(
            pub_date__lte=timezone.now()
        ).order_by("-pub_date")[:5]

# By default, the DetailView generic view uses a template called 
# <app name>/<model name>_detail.html. In our case, it would use the 
# template "polls/question_detail.html". The template_name attribute is 
# used to tell Django to use a specific template name instead of the 
# autogenerated default template name. We also specify the template_name 
# for the results list view – this ensures that the results view and the 
# detail view have a different appearance when rendered, even though 
# they’re both a DetailView.
class DetailView(generic.DetailView):
    model = Question
    template_name = "polls/detail.html"

    def get_queryset(self):
        """
        Excludes any questions that aren't published yet.
        """
        return Question.objects.filter(pub_date__lte=timezone.now())

class ResultView(generic.DetailView):
    model = Question
    template_name = "polls/results.html"

# The implemented views above are Generic views which can be used to
# facilitate the development of consolidate web development patterns.
# You can see more in notes/views.txt.
# Below you have the default implementation of a view.

# def index(request: HttpRequest):
#     latest_question_list = Question.objects.order_by("-pub_date")[:5]
#     # Loads the template.
#     template = loader.get_template("polls/index.html")
#     # The context is a dictionary mapping template variable names to Python
#     # objects.
#     context = {
#         "latest_question_list": latest_question_list
#     }
#     return HttpResponse(template.render(context, request))
#     # It’s a very common idiom to load a template, fill a context and 
#     # return an HttpResponse object with the result of the rendered 
#     # template. Django provides a shortcut:
#     # return render(request, "polls/index.html", context)

# def detail(request, question_id):
#     try:
#         question = Question.objects.get(pk=question_id)
#     except Question.DoesNotExist:
#         raise Http404("Question does not exist")
#     return render(request, "polls/detail.html", {"question": question})
#     # shotcut:
#     # question = get_object_or_404(Question, pk=question_id)
#     # return ...
#     # you can also use get_list_or_404(), which works just like
#     # get_object_or_404() - except using filter() instead of get().
# 
# def results(request, question_id):
#     question = get_object_or_404(Question, pk=question_id)
#     return render(request, "polls/result.html", {"question": question})

def vote(request, question_id):
    question = get_object_or_404(Question, pk=question_id)
    try:
        selected_choice = question.choice_set.get(
            # request.POST is a dictionary-like object that lets you access
            # submited data by key name.
            # Django also provides request.GET for accessing data in the
            # same way.
            pk=request.POST["choice"]
        )
    except (KeyError, Choice.DoesNotExist):
        return render(
            request,
            "polls/detail.html",
            {
                "question": question,
                "error_message": "You didn't select a choice"
            }
        )
    else:
        selected_choice.votes = F("votes") + 1
        selected_choice.save()
        # Always return an HttpResponseRedirect after successfully dealing
        # with POST data. This prevents data from being posted twice if a
        # user hits the Back button.    return HttpResponse(
        return HttpResponseRedirect(
            reverse(
                "polls:results",
                args=(question.id,)
            )
        )

def get_questions(request: HttpRequest):
    if request.GET:
        if request.GET.get("id"):
            # Django provides a rich database lookup API that's entirely 
            # driven by keyword arguments.
            p = Question.objects.filter(id=request.GET.get("id"))
            print(p)
            if p:
                print("publised recently:", p[0].was_published_recently())
        if request.GET.get("question_text"):
            # There's also aditional filters that can be applyied to each
            # argument.
            p = Question.objects.filter(
                    question_text__startswith=request.GET.get(
                        "question_text"
                    )
                )
            print(p)
            if p:
                print("publised recently:", p[0].was_published_recently())
    else:
        # Gets all objects
        print(Question.objects.all())
    return HttpResponse(b"question list")

def create_question(request: HttpRequest):
    # Support for time zones is enabled in the default settings file, so
    # Django expects a datetime with tzinfo for pub_date.
    q = Question(question_text="What's new?", pub_date=timezone.now())
    # Save the object into the database.
    q.save()
    # After saving, the object now has an id.
    resp = f"question created, id: {q.id}"
    return HttpResponse(bytes(resp, "utf-8"))
